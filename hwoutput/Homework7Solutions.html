<h1 id="question-1">Question 1</h1>
<h2 id="-a-asynchronous-javascript">(a) Asynchronous Javascript</h2>
<p>The output will be:</p>
<p>myTime = 1, elapsedTime = 1.0<br>myTime = 2, elapsedTime = 1.0<br>myTime = 3, elapsedTime = 1.0<br>myTime = 4, elapsedTime = 1.0  </p>
<p>This is because the four calls to setTimeout will only add four instances of<br>advanceTime to the event queue at nearly the same time, without any pause in<br>between. Then after waiting for one second, each instance of advanceTime runs<br>one after another, quickly enough that it looks like they all ran at the same<br>time.    </p>
<h2 id="-b-promises-promises">(b) Promises, Promises</h2>
<p>The output for this code was:</p>
<p>myTime = 1, elapsedTime = 0<br>myTime = 2, elapsedTime = 0.002<br>myTime = 3, elapsedTime = 0.002<br>myTime = 4, elapsedTime = 0.002  </p>
<p>This still doesn&#39;t work correctly because the elapsed time is not increasing<br>by 1 second like it is supposed to. The mistake here is that the promises were<br>not chained in any way. You just have four calls to advanceTime that will run<br>consecutively. Each advanceTime instance returns a promise, but the next<br>instance of advanceTime is not waiting for that promise to resolve. You could<br>fix this by chaining:  </p>
<pre><code>oneSecond()
  .then(advanceTime)
  .then(advanceTime)
  .then(advanceTime)
  .then(advanceTime);</code></pre><h2 id="-c-requests-in-series-with-promises">(c) Requests in Series with Promises</h2>
<p>The modified code is:</p>
<pre><code>const rp = require(&#39;request-promise-native&#39;);
let site1 = {
    uri: &#39;https://www.youtube.com&#39;,
    method: &#39;HEAD&#39;, // What does this do?
    resolveWithFullResponse: true
};

let site2 = {
    uri: &#39;https://www.bbc.com/news&#39;,
    method: &#39;HEAD&#39;,
    resolveWithFullResponse: true
};

let site3 = {
    uri: &#39;https://www.nst.com.my&#39;,
    method: &#39;HEAD&#39;,
    resolveWithFullResponse: true
};

let start = new Date();
rp(site1).then(res =&gt; {
    let time = (new Date() - start)/1000;
    console.log(`YouTube status: ${res.statusCode}, time: ${time}`);
    return rp(site2);
}).then(res =&gt; {
    let time = (new Date() - start)/1000;
    console.log(`BBC News status: ${res.statusCode}, time: ${time}`);
    return rp(site3);
}).then(res =&gt; {
    let time = (new Date() - start)/1000;
    console.log(`New Straits Times status: ${res.statusCode}, time: ${time}`);
})
console.log(&quot;Starting my web requests:&quot;);</code></pre><p>The output is: </p>
<p>Starting my web requests:<br>YouTube status: 200, time: 1.254<br>BBC News status: 200, time: 1.31<br>New Straits Times status: 200, time: 1.731  </p>
<p>The main advantage of using promises in this case is that you can guarantee the<br>order in which these sites are visited. </p>
<h2 id="-d-requests-in-parallel-with-promises">(d) Requests in Parallel with Promises</h2>
<p>The modified code is:</p>
<pre><code>const rp = require(&#39;request-promise-native&#39;);
let site1 = {
    uri: &#39;https://www.youtube.com&#39;,
    method: &#39;HEAD&#39;, // What does this do?
    resolveWithFullResponse: true
};

let site2 = {
    uri: &#39;https://www.bbc.com/news&#39;,
    method: &#39;HEAD&#39;,
    resolveWithFullResponse: true
};

let site3 = {
    uri: &#39;https://www.nst.com.my&#39;,
    method: &#39;HEAD&#39;,
    resolveWithFullResponse: true
};

let start = new Date();
let p1 = rp(site1).then(res =&gt; {
    let time = (new Date() - start)/1000;
    return console.log(`YouTube status: ${res.statusCode}, time: ${time}`);});

let p2 = rp(site2).then(res =&gt; {
    let time = (new Date() - start)/1000;
    return console.log(`BBC News status: ${res.statusCode}, time: ${time}`);
});

let p3 = rp(site3).then(res =&gt; {
    let time = (new Date() - start)/1000;
    return console.log(`New Straits Times status: ${res.statusCode}, time: ${time}`);
});

console.log(&quot;Starting my web requests:&quot;);
Promise.all([p1, p2, p3]).then(x=&gt;{
    console.log(&quot;All Finished&quot;);
});</code></pre><p>The output is:</p>
<p>Starting my web requests:<br>BBC News status: 200, time: 0.143<br>New Straits Times status: 200, time: 0.44<br>YouTube status: 200, time: 1.517<br>All Finished  </p>
<p>The advantage here is that we might save some time running requests in parallel<br>instead of having to wait for each request to finish before running the next.<br>But now the order is not guaranteed. </p>
<h1 id="question-2">Question 2</h1>
<h2 id="-a-json-server-and-database">(a) JSON Server and Database</h2>
<pre><code>app.put(&#39;/register&#39;, jsonencodedParser, function(req,res) {
  let user = req.body;
  db.find({&quot;name&quot;: user.name}, function(err,docs) {
    if(err) 
      {console.log(&quot;database error&quot;);}
    else 
    {
      let response = {};
      if(docs.length == 0)
      {
        db.insert(user);
        response.registration = &quot;succeeded&quot;;
        response.user = user.name;
        response.reason = undefined;
        res.send(JSON.stringify(response));
      }
      else
      {
        response.registration = &quot;failed&quot;;
        response.user = user.name;
        response.reason = &quot;user already exists&quot;;
        res.send(JSON.stringify(response));
      }
    }
  });
});</code></pre><h2 id="-b-test-the-register-path">(b) Test the &quot;/register&quot; path</h2>
<p>Code:  </p>
<pre><code>request.put({uri:&quot;http://0.0.0.0:8080/register&quot;, json:true, body:{&quot;name&quot;:&quot;Owen&quot;, &quot;nickname&quot;:&quot;Vanilla&quot;}}, function(error,response,body) {
  console.log(body);
});

request.put({uri:&quot;http://0.0.0.0:8080/register&quot;, json:true, body:{&quot;name&quot;:&quot;Steve&quot;, &quot;nickname&quot;:&quot;Outback&quot;}}, function(error,response,body) {
  console.log(body);
});

request.put({uri:&quot;http://0.0.0.0:8080/register&quot;, json:true, body:{&quot;name&quot;:&quot;Pack&quot;, &quot;nickname&quot;:&quot;Half-Pint&quot;}}, function(error,response,body) {
  console.log(body);
});

request.put({uri:&quot;http://0.0.0.0:8080/register&quot;, json:true, body:{&quot;name&quot;:&quot;Danny&quot;, &quot;nickname&quot;:&quot;Doughboy&quot;}}, function(error,response,body) {
  console.log(body);
});

request.put({uri:&quot;http://0.0.0.0:8080/register&quot;, json:true, body:{&quot;name&quot;:&quot;Karen&quot;, &quot;nickname&quot;:&quot;Six Feet&quot;}}, function(error,response,body) {
  console.log(body);
});</code></pre><p>First run:<br>{&quot;registration&quot;:&quot;succeeded&quot;,&quot;user&quot;:&quot;Owen&quot;}<br>{&quot;registration&quot;:&quot;succeeded&quot;,&quot;user&quot;:&quot;Steve&quot;}<br>{&quot;registration&quot;:&quot;succeeded&quot;,&quot;user&quot;:&quot;Pack&quot;}<br>{&quot;registration&quot;:&quot;succeeded&quot;,&quot;user&quot;:&quot;Danny&quot;}<br>{&quot;registration&quot;:&quot;succeeded&quot;,&quot;user&quot;:&quot;Karen&quot;}  </p>
<p>Second run:<br>{&quot;registration&quot;:&quot;failed&quot;,&quot;user&quot;:&quot;Owen&quot;,&quot;reason&quot;:&quot;user already exists&quot;}<br>{&quot;registration&quot;:&quot;failed&quot;,&quot;user&quot;:&quot;Steve&quot;,&quot;reason&quot;:&quot;user already exists&quot;}<br>{&quot;registration&quot;:&quot;failed&quot;,&quot;user&quot;:&quot;Pack&quot;,&quot;reason&quot;:&quot;user already exists&quot;}<br>{&quot;registration&quot;:&quot;failed&quot;,&quot;user&quot;:&quot;Danny&quot;,&quot;reason&quot;:&quot;user already exists&quot;}<br>{&quot;registration&quot;:&quot;failed&quot;,&quot;user&quot;:&quot;Karen&quot;,&quot;reason&quot;:&quot;user already exists&quot;}  </p>
<h2 id="-c-add-an-allusers-path-and-functionality">(c) Add an &quot;/allUsers&quot; path and functionality</h2>
<pre><code>app.get(&#39;/allUsers&#39;, function(req,res) {
  let time = new Date();
  let response = {&quot;date&quot;:time.toString()};
  db.find({}, function(err,docs) {
    if(err) 
      {console.log(&quot;database error&quot;);}
    else
    {
      let names = [];
      for(let doc of docs)
        names.push(doc.name);
      response.users = names;
      res.send(JSON.stringify(response));
    }
  });
});</code></pre><h2 id="-d-test-the-allusers-path">(d) Test the &quot;/allUsers&quot; path</h2>
<p>Code:  </p>
<pre><code>request.get(&quot;http://0.0.0.0:8080/allUsers&quot;, function(error,response,body) {
  console.log(body);
})</code></pre><p>Output:<br>{&quot;date&quot;:&quot;Mon Oct 22 2018 15:56:17 GMT-0700 (PDT)&quot;,&quot;users&quot;:[&quot;Danny&quot;,&quot;Karen&quot;,&quot;Pack&quot;,&quot;Steve&quot;,&quot;Owen&quot;]}  </p>
<h2 id="-e-nickname-interface">(e) Nickname interface</h2>
<pre><code>app.get(&#39;/nickname&#39;, jsonencodedParser, function(req,res) {
  let query = req.body;
  console.log(query);
  db.find({&quot;name&quot;: query.user}, function(err,docs) {
    if(err) 
      {console.log(&quot;database error&quot;);}
    else
    {
      let response = {};
      if(docs.length == 0)
      {
        response.user = query.user;
        response.error = &quot;Not Found&quot;;
        res.send(JSON.stringify(response));
      }
      else
      {
        response.user = docs[0].name;
        response.nickname = docs[0].nickname;
        res.send(JSON.stringify(response));
      }
    }
  });
});</code></pre><h2 id="-f-test-the-nickname-interface">(f) Test the Nickname interface</h2>
<p>Code:  </p>
<pre><code>request.get({uri:&quot;http://0.0.0.0:8080/nickname&quot;, json:true, body:{&quot;user&quot;:&quot;Karen&quot;}}, function(error,response,body) {
  console.log(body);
});

request.get({uri:&quot;http://0.0.0.0:8080/nickname&quot;, json:true, body:{&quot;user&quot;:&quot;Danny&quot;}}, function(error,response,body) {
  console.log(body);
});

request.get({uri:&quot;http://0.0.0.0:8080/nickname&quot;, json:true, body:{&quot;user&quot;:&quot;Joe&quot;}}, function(error,response,body) {
  console.log(body);
});</code></pre><p>Output:<br>{ user: &#39;Karen&#39;, nickname: &#39;Six Feet&#39; }<br>{ user: &#39;Danny&#39;, nickname: &#39;Doughboy&#39; }<br>{ user: &#39;Joe&#39;, error: &#39;Not Found&#39; }  </p>
<h1 id="question-3">Question 3</h1>
<h2 id="-a-the-cookies-path-attribute">(a) The Cookies Path Attribute</h2>
<p>In the &quot;/&quot; path the three cookies are sent. In the &quot;/&quot; path only the firstcookie<br>is got back from the browser because it is the only one with the &quot;/&quot; path<br>attribute. In the the &quot;/left&quot; path there are two cookies received from the<br>browser: firstcookie and secondcookie. This is because they have path attributes<br>that match the url (i.e. &quot;/&quot; and &quot;/left&quot;). In the &quot;/right&quot; path there are also<br>only two cookies received: firstcookie and thirdcookie. Since &quot;/&quot; and &quot;/right&quot;<br>match, the cookies with these path attributes are sent to the server.  </p>
<h2 id="-b-cookies-and-the-request-library">(b) Cookies and the <em>Request</em> Library</h2>
<p>Output:<br>Starting my web requests:<br>Testing cookies, &quot;/&quot; path, client sent: {undefined}<br>Testing cookies, &quot;/left&quot; path, client sent: {undefined}<br>Testing cookies, &quot;/right&quot; path, client sent: {undefined}  </p>
<p>These results are different than part (a). This is because in <em>request</em> cookies<br>are not saved by default so no cookies are sent back to the server. In order to<br>use cookies they need to be saved in a &quot;jar&quot; and the subsequent request calls<br>need to be nested in the first call so that they share the same jar (I think).</p>
<h2 id="-c-using-cookies-with-the-request-library">(c) Using Cookies with the <em>Request</em> Library</h2>
<p>Output:<br>Starting my web requests:<br>Testing cookies, &quot;/&quot; path, client sent: {undefined}<br>Testing cookies, &quot;/left&quot; path, client sent: {secondcookie=leftcookie; firstcookie=midcookie}<br>Testing cookies, &quot;/right&quot; path, client sent: {thirdcookie=rightcookie; firstcookie=midcookie}<br>Testing cookies, &quot;/&quot; path, client sent: {firstcookie=midcookie}  </p>
<h1 id="question-4">Question 4</h1>
<h2 id="-a-password-authentication">(a) Password Authentication</h2>
